insist_matrix <- function(x) {
  if (!("matrix" %in% class(x))) x <- as.matrix(x)
  x
}

#' Elementary voice leadings which generate a set's transpositions
#'
#' Just as the transpositions of the diatonic scale can be generated by
#' [Hook (2008)](https://doi.org/10.1515/9781580467476-008)'s elementary
#' "signature transformation," the transpositional voice leadings of any
#' set can generally be decomposed into a small number of basic motions.
#' These motions correspond to the arrows in a set's [brightnessgraph()].
#' (The qualifier "generally" is needed because of certain problematic edge
#' cases, such as the perfectly even scales of [edoo()] whose minimal voice
#' leadings always involve entirely parallel motion, which cannot be 
#' derived from "mode shift" voice leadings represnted on a brightness graph.)
#' `vl_generators()` identifies these basic voice-leading motions.
#'
#' @inheritParams tnprime
#' @inheritParams minimizeVL
#'
#' @returns 2-by-m matrix whose m columns represent the m distinct voice-leading
#'   generators. The top row indicates the generic size of each interval; the 
#'   bottom row indicates the specific size. Columns are sorted according to the 
#'   size of their induced voice leading.
#'
#' @examples
#' diatonic_scale <- c(0, 2, 4, 5, 7, 9, 11)
#' melodic_minor <- c(0, 2, 3, 5, 7, 9, 11)
#' vl_generators(diatonic_scale)
#' vl_generators(melodic_minor)
#' vl_generators(j(dia))
#'
#' maj7 <- c(0, 4, 7, 11)
#' vl_generators(maj7)
#' vl_generators(maj7, method="euclidean")
#'
#' @export
vl_generators <- function(set, 
                          method=c("taxicab", "euclidean", "chebyshev", "hamming"),
                          edo=12,
                          rounder=10) {
  method <- match.arg(method)
  tiny <- 10^(-1 * rounder)
  card <- length(set)

  if (evenness(set, edo=edo) < tiny) {
    stop("Perfectly even scales have no voice-leading generators")
  }

  scalar_interval_matrix <- sim(set,edo)

  reduced_comparisons <- bg_reduction(set=set, edo=edo, rounder=rounder)
  arrows_in_graph  <- which(reduced_comparisons==1, arr.ind=TRUE)
  from_which_mode <- arrows_in_graph[,1]
  generic_intervals <- (arrows_in_graph[,2] - from_which_mode) %% card
  generic_intervals <- (generic_intervals + 1)
  specific_intervals <- scalar_interval_matrix[cbind(generic_intervals, from_which_mode)]
  
  # Reformat the intervals so their display value is more human readable
  generic_intervals <- (-1*(generic_intervals-1)) %% card
  specific_intervals <- (-1 * specific_intervals) %% edo

  duplications <- duplicated(round(specific_intervals, digits=rounder))
  res <- rbind(generic_intervals, specific_intervals)
  res <- res[, !duplications]
  
  res <- insist_matrix(res)

  measure_vl <- function(vec) {
    vl <- tn(set, vec[2], sorted=FALSE) - rotate(set, vec[1])
    dist_func(vl, method=method, rounder=rounder)
  }

  res <- res[,order(res[2,])]
  res <- insist_matrix(res)

  vl_distances <- apply(res, 2, measure_vl)

  res <- res[,order(vl_distances)]
  res <- insist_matrix(res)

  res
}